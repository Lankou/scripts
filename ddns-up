#!/bin/bash

PIDFILE=/var/run/ddns.pid
LOGFILE=/var/log/ddns-up.log
APIURL="https://dnsapi.cn"
GETIPURL=
LOGIN=
PASS=
DOMAIN=
SUBDOM=
INTERVAL="120"

logtime() { date +"%Y-%m-%d %H:%M:%S"; }
action() { curl -4 --silent -X POST "$@"; }
jsonpretty() { python -mjson.tool; }
getip() { action $GETIPURL; }
getip_post() { tr -d "\n"; }
getinfo() { action $APIURL/Domain.List -d $QUERY; }
getdomid() { jsonpretty | grep -E '\"name\":.*\"'$DOMAIN'\"' -n5 | grep \"id\" | grep -Eo '[0-9]{4,}'; }
getdominfo() { action $APIURL/Record.List -d $QUERY$RECLIST; }
getrecid() { jsonpretty | grep -E '\"name\":.*\"'$SUBDOM'\"' -n5 | grep \"id\" | grep -Eo '[0-9]{4,}'; }
getrecord() { action $APIURL/Record.Info -d $QUERY$DOMINFO; }
getrecord_post() { jsonpretty | grep value | cut -d: -f2 | tr -d "\"" | tr -d " "; }
updateip() { action $APIURL/Record.Ddns -d $UPDATE; }
checkinfo() {
  echo $ACCINFO | grep "successful" &> /dev/null
  if [ ${PIPESTATUS[1]} -eq 0 ]; then
    SUCCESS=true
  else
    SUCCESS=false
  fi
}

FORMAT="json"
RECLINE="默认"
QUERY="login_email=$LOGIN&login_password=$PASS&format=$FORMAT"
ACCINFO=$(getinfo)

SUCCESS=false
i=0
while [[ "$SUCCESS" = "false" && $i -le 5 ]]; do
  echo "$(logtime): Trying to get account information..." | tee -a $LOGFILE
  checkinfo
  [ $i -ne 0 ] && echo "$(logtime): Retrying. Count: $i" | tee -a $LOGFILE
  let i+=1
done

if [ "$SUCCESS" = "false" ]; then
  echo "$(logtime): Cannot obtain account informaton. Exiting..." | tee -a $LOGFILE
  exit 1
fi

echo "$(logtime): Account information acquired." | tee -a $LOGFILE

DOMID=$(echo "$ACCINFO" | getdomid)
RECLIST="&domain_id=$DOMID"
RECID=$(getdominfo | getrecid)
DOMINFO="&domain_id=$DOMID&record_id=$RECID"
UPDATE=$QUERY$DOMINFO"&record_line=$RECLINE&sub_domain=$SUBDOM"

# Check for previously running instances.
# If one exists, see if it's alive.
# If yes, abort. If no, delete stale PID file (if exists) and start the process.
# TODO:
# * To support IPv6 (currently it should favor IPv6 as most systems' default, unless you have
#   tweaked your system to use IPv4 first or IPv6 times out.)
# * Handle situations where another process running under the old PID. Although this is a
#   rare case, but it should be under consideration.

if [ -f $PIDFILE ]; then
  echo "$(logtime): PID file exists. Checking for running process." | tee -a $LOGFILE
  ps up $(cat $PIDFILE) &> /dev/null
  if [ $? -ne 0 ]; then
    echo "$(logtime): PID is stale. Remove and starting." | tee -a $LOGFILE
    rm $PIDFILE
    echo $$ > $PIDFILE
  else
    echo "$(logtime): Process is still up and running. Script aborted." | tee -a $LOGFILE
  fi
else
  echo $$ > $PIDFILE
fi

# Non-stop loop for checking the DDNS status.
# It will get the record from DNSPod every $INTERVAL seconds.
# If the record on server is the same as getip()'s result, then sleep for $INTERVAL seconds.
# If not, update the record then sleep.

while true; do
  MYIP=$(getip | getip_post)
  DOMIP=$(getrecord | getrecord_post)
  if [ $MYIP = $DOMIP ]; then
    echo "$(logtime): IP not changed: $MYIP. Sleeping for $INTERVAL seconds." | tee -a $LOGFILE
    sleep $INTERVAL
  else
    echo "$(logtime): IP change detected. Original: $DOMIP -- Updating to: $MYIP " | tee -a $LOGFILE
    updateip
    sleep $INTERVAL
  fi
done
